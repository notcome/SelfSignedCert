//  Copyright © 2016 Stefan van den Oord. All rights reserved.

import Foundation
import Quick
import Nimble
import SwiftBytes
@testable import SelfSignedCert

class DERTests : QuickSpec {
    
    override func spec() {
        
        describe("DER encoding") {
            it("can encode NULL") {
                expect(NSNull().toDER()) == [0x05, 0x00]
            }
            
            it("can encode booleans") {
                expect(true.toDER()) == [0x01,0x01,0xFF]
                expect(false.toDER()) == [0x01,0x01,0x00]
            }
            
            it("can encode integers") {
                expect(0.toDER()) == [0x02,0x01,0x00]
                expect(1.toDER()) == [0x02,0x01,0x01]
                expect((-1).toDER()) == [0x02,0x01,0xFF]
                expect(72.toDER()) == [0x02,0x01,0x48]
                expect((-128).toDER()) == [0x02,0x01,0x80]
                expect(128.toDER()) == [0x02,0x02,0x00,0x80]
                expect(255.toDER()) == [0x02,0x02,0x00,0xFF]
                expect((-256).toDER()) == [0x02,0x02,0xFF,0x00]
                expect(12345.toDER()) == [0x02,0x02,0x30,0x39]
                expect((-12345).toDER()) == [0x02,0x02,0xCF,0xC7]
                expect(123456789.toDER()) == [0x02,0x04,0x07,0x5B,0xCD,0x15]
                expect((-123456789).toDER()) == [0x02,0x04,0xF8,0xA4,0x32,0xEB]
            }
            
            it("can encode strings") {
                expect("".toDER()) == [0x13, 0x00]
                expect("hello".toDER()) == [0x13, 0x05, 0x68, 0x65, 0x6c, 0x6c, 0x6f]
                expect("thérè".toDER()) == [0x0c, 0x07, 0x74, 0x68, 0xc3, 0xa9, 0x72, 0xc3, 0xa8]
            }
            
            it("can encode a long string") {
                let str = "Lorém ipsum dolor sit amet, consectetur adipiscing elit. Aliquam in felis a libero pharetra pellentesque. Mauris et dui vel velit vulputate iaculis eget non orci. Pellentesque magna mauris, finibus et dolor eget, convallis placerat est. Suspendisse ac finibus diam, sed iaculis nulla. Aliquam eu gravida magna. Maecenas aliquam arcu ut odio convallis laoreet. Pellentesque augue dui, feugiat nec felis pharetra, lacinia vulputate risus. Quisque at orci libero. Vestibulum blandit ipsum vel libero elementum, vestibulum interdum nibh tincidunt. Cras eu elementum urna. Integer quis magna sed quam aliquam suscipit."
                
//                var out = ""
//                for b in str.toDER() {
//                    out += String(format: "0x%.2x, ", b)
//                }
//                print(out)
                expect(str.toDER()) == [0x0c, 0x82, 0x02, 0x66, 0x4c, 0x6f, 0x72, 0xc3, 0xa9, 0x6d, 0x20, 0x69, 0x70, 0x73, 0x75, 0x6d, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x73, 0x69, 0x74, 0x20, 0x61, 0x6d, 0x65, 0x74, 0x2c, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x63, 0x74, 0x65, 0x74, 0x75, 0x72, 0x20, 0x61, 0x64, 0x69, 0x70, 0x69, 0x73, 0x63, 0x69, 0x6e, 0x67, 0x20, 0x65, 0x6c, 0x69, 0x74, 0x2e, 0x20, 0x41, 0x6c, 0x69, 0x71, 0x75, 0x61, 0x6d, 0x20, 0x69, 0x6e, 0x20, 0x66, 0x65, 0x6c, 0x69, 0x73, 0x20, 0x61, 0x20, 0x6c, 0x69, 0x62, 0x65, 0x72, 0x6f, 0x20, 0x70, 0x68, 0x61, 0x72, 0x65, 0x74, 0x72, 0x61, 0x20, 0x70, 0x65, 0x6c, 0x6c, 0x65, 0x6e, 0x74, 0x65, 0x73, 0x71, 0x75, 0x65, 0x2e, 0x20, 0x4d, 0x61, 0x75, 0x72, 0x69, 0x73, 0x20, 0x65, 0x74, 0x20, 0x64, 0x75, 0x69, 0x20, 0x76, 0x65, 0x6c, 0x20, 0x76, 0x65, 0x6c, 0x69, 0x74, 0x20, 0x76, 0x75, 0x6c, 0x70, 0x75, 0x74, 0x61, 0x74, 0x65, 0x20, 0x69, 0x61, 0x63, 0x75, 0x6c, 0x69, 0x73, 0x20, 0x65, 0x67, 0x65, 0x74, 0x20, 0x6e, 0x6f, 0x6e, 0x20, 0x6f, 0x72, 0x63, 0x69, 0x2e, 0x20, 0x50, 0x65, 0x6c, 0x6c, 0x65, 0x6e, 0x74, 0x65, 0x73, 0x71, 0x75, 0x65, 0x20, 0x6d, 0x61, 0x67, 0x6e, 0x61, 0x20, 0x6d, 0x61, 0x75, 0x72, 0x69, 0x73, 0x2c, 0x20, 0x66, 0x69, 0x6e, 0x69, 0x62, 0x75, 0x73, 0x20, 0x65, 0x74, 0x20, 0x64, 0x6f, 0x6c, 0x6f, 0x72, 0x20, 0x65, 0x67, 0x65, 0x74, 0x2c, 0x20, 0x63, 0x6f, 0x6e, 0x76, 0x61, 0x6c, 0x6c, 0x69, 0x73, 0x20, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x72, 0x61, 0x74, 0x20, 0x65, 0x73, 0x74, 0x2e, 0x20, 0x53, 0x75, 0x73, 0x70, 0x65, 0x6e, 0x64, 0x69, 0x73, 0x73, 0x65, 0x20, 0x61, 0x63, 0x20, 0x66, 0x69, 0x6e, 0x69, 0x62, 0x75, 0x73, 0x20, 0x64, 0x69, 0x61, 0x6d, 0x2c, 0x20, 0x73, 0x65, 0x64, 0x20, 0x69, 0x61, 0x63, 0x75, 0x6c, 0x69, 0x73, 0x20, 0x6e, 0x75, 0x6c, 0x6c, 0x61, 0x2e, 0x20, 0x41, 0x6c, 0x69, 0x71, 0x75, 0x61, 0x6d, 0x20, 0x65, 0x75, 0x20, 0x67, 0x72, 0x61, 0x76, 0x69, 0x64, 0x61, 0x20, 0x6d, 0x61, 0x67, 0x6e, 0x61, 0x2e, 0x20, 0x4d, 0x61, 0x65, 0x63, 0x65, 0x6e, 0x61, 0x73, 0x20, 0x61, 0x6c, 0x69, 0x71, 0x75, 0x61, 0x6d, 0x20, 0x61, 0x72, 0x63, 0x75, 0x20, 0x75, 0x74, 0x20, 0x6f, 0x64, 0x69, 0x6f, 0x20, 0x63, 0x6f, 0x6e, 0x76, 0x61, 0x6c, 0x6c, 0x69, 0x73, 0x20, 0x6c, 0x61, 0x6f, 0x72, 0x65, 0x65, 0x74, 0x2e, 0x20, 0x50, 0x65, 0x6c, 0x6c, 0x65, 0x6e, 0x74, 0x65, 0x73, 0x71, 0x75, 0x65, 0x20, 0x61, 0x75, 0x67, 0x75, 0x65, 0x20, 0x64, 0x75, 0x69, 0x2c, 0x20, 0x66, 0x65, 0x75, 0x67, 0x69, 0x61, 0x74, 0x20, 0x6e, 0x65, 0x63, 0x20, 0x66, 0x65, 0x6c, 0x69, 0x73, 0x20, 0x70, 0x68, 0x61, 0x72, 0x65, 0x74, 0x72, 0x61, 0x2c, 0x20, 0x6c, 0x61, 0x63, 0x69, 0x6e, 0x69, 0x61, 0x20, 0x76, 0x75, 0x6c, 0x70, 0x75, 0x74, 0x61, 0x74, 0x65, 0x20, 0x72, 0x69, 0x73, 0x75, 0x73, 0x2e, 0x20, 0x51, 0x75, 0x69, 0x73, 0x71, 0x75, 0x65, 0x20, 0x61, 0x74, 0x20, 0x6f, 0x72, 0x63, 0x69, 0x20, 0x6c, 0x69, 0x62, 0x65, 0x72, 0x6f, 0x2e, 0x20, 0x56, 0x65, 0x73, 0x74, 0x69, 0x62, 0x75, 0x6c, 0x75, 0x6d, 0x20, 0x62, 0x6c, 0x61, 0x6e, 0x64, 0x69, 0x74, 0x20, 0x69, 0x70, 0x73, 0x75, 0x6d, 0x20, 0x76, 0x65, 0x6c, 0x20, 0x6c, 0x69, 0x62, 0x65, 0x72, 0x6f, 0x20, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x75, 0x6d, 0x2c, 0x20, 0x76, 0x65, 0x73, 0x74, 0x69, 0x62, 0x75, 0x6c, 0x75, 0x6d, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x64, 0x75, 0x6d, 0x20, 0x6e, 0x69, 0x62, 0x68, 0x20, 0x74, 0x69, 0x6e, 0x63, 0x69, 0x64, 0x75, 0x6e, 0x74, 0x2e, 0x20, 0x43, 0x72, 0x61, 0x73, 0x20, 0x65, 0x75, 0x20, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x75, 0x6d, 0x20, 0x75, 0x72, 0x6e, 0x61, 0x2e, 0x20, 0x49, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x71, 0x75, 0x69, 0x73, 0x20, 0x6d, 0x61, 0x67, 0x6e, 0x61, 0x20, 0x73, 0x65, 0x64, 0x20, 0x71, 0x75, 0x61, 0x6d, 0x20, 0x61, 0x6c, 0x69, 0x71, 0x75, 0x61, 0x6d, 0x20, 0x73, 0x75, 0x73, 0x63, 0x69, 0x70, 0x69, 0x74, 0x2e]
            }
            
            it("can encode bitstring") {
                let str = "test"
                let data = str.data(using: String.Encoding.utf8)!
                let bitString = BitString(data: data)
                expect(bitString.toDER()) == [0x03, 0x05, 0x00, 0x74, 0x65, 0x73, 0x74]
            }
            
            it("can encode dates") {
                expect(Date(timeIntervalSinceReferenceDate: 265336576).toDER()) == [0x18, 0x0F] + [UInt8]("20090530003616Z".utf8)
            }

            describe("OID") {
                it("can encode empty OID") {
                    expect(OID(components:[]).toDER()) == [0x06, 0x00]
                }
                
                it("collapses first two bytes if required") {
                    expect(OID(components:[0,2]).toDER()) == [0x06, 0x01, 0x02]
                    expect(OID(components:[1,2]).toDER()) == [0x06, 0x01, 0x2a]
                    expect(OID(components:[2,3]).toDER()) == [0x06, 0x01, 0x53]
                    // The original code has the following cases.
                    // But from X.690 spec, it is clearly stated that:
                    //
                    // > This packing of the first two object identifier components recognizes that
                    // > only three values are allocated from the root node, and at most 39 subsequent
                    // > values from nodes reached by X = 0 and X = 1.
//                    expect(OID(components:[4,1]).toDER()) != [0x06, 0x01, 0xA1]
//                    expect(OID(components:[1,42]).toDER()) != [0x06, 0x01, 0x52]
                }
                
                it("can encode OID 1") {
                    let oid: OID = [1,2,840,113549,1,1,1]
                    expect(oid.toDER()) == [0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,  0xf7, 0x0d, 0x01, 0x01,  0x01]
                }
                
                it("can encode OID 2") {
                    let oid: OID = [2,5,4,4]
                    expect(oid.toDER()) == [0x06, 0x03, 0x55, 0x04, 0x04]
                }
                
                it("can encode OID 3") {
                    expect(OID(components: [1, 2, 840, 113549, 1, 9, 1]).toDER()) == [0x06, 0x09, 0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x09,0x01]
                }
            }
            
            describe("ASN.1 Objects") {
                it("can encode ASN.1 object with components") {
                    expect(ASN1Object(tag:0, tagClass:2, components:[NSNumber(value:2 as Int)]).toDER()) == [0xa0, 0x03, 0x02, 0x01, 0x02]
                }
                it("can encode ASN.1 object without components") {
                    let data = [UInt8]("test".utf8)
                    expect(ASN1Object(tag:1, tagClass:2, constructed:false, value:data).toDER()) == [0x81, 0x04, 0x74, 0x65, 0x73, 0x74]
                    expect(ASN1Object(tag:2, tagClass:0, constructed:true, value:data).toDER()) == [0x22, 0x04, 0x74, 0x65, 0x73, 0x74]
                }
            }
            
            describe("Array") {
                it("can encode an array") {
                    let array:NSArray = [42, "hoi", true];
                    expect(array.toDER()) == [0x30, 0x0b, 0x02, 0x01, 0x2a, 0x13, 0x03, 0x68, 0x6f, 0x69, 0x01, 0x01, 0xff]
                }
            }
            
            describe("Nested array") {
                it("can encode a nested array") {
                    let nestedArray:NSArray = [ [42, "höi", true] as NSArray ];
                    expect(nestedArray.toDER()) == [0x30, 0x0e, 0x30, 0x0c, 0x02, 0x01, 0x2a, 0x0c, 0x04, 0x68, 0xc3, 0xb6, 0x69, 0x01, 0x01, 0xff]
                }
            }
            
            describe("Set") {
                it("can encode a set") {
                    let set:NSSet = [42, "höi", true]
                    expect(set.toDER()) == [0x31, 0x0c, 0x02, 0x01, 0x2a, 0x0c, 0x04, 0x68, 0xc3, 0xb6, 0x69, 0x01, 0x01, 0xff]
                }
            }
        }
    }
}
